//go:build mage

package main

import (
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/magefile/mage/mg"
	"github.com/magefile/mage/sh"
)

// List Available Commands The Magefile Provides.
func Help() error {
	helpMsg := "You can run the following commands:\n" +
		"mage wizard   - [TODO] The Setup Wizard. When In Doubt...\n" +
		"mage build    - Build binary from source from proj dir.\n" +
		"mage run      - Run binary generated by the build command.\n" +
		"mage rerun    - Rebuild binary and run it in one command.\n" +
		"mage serve    - [TODO] Serve Δ; Host A Multiplayer Session.\n" +
		"mage depends  - Install depends for your given platform / OS\n" +
		"mage switch   - Switch between our main branch and the G3N port.\n" +
		"mage update   - Update to the latest commit, if Git is available\n" +
		"mage install  - Install build to a dot directory in user's home\n" +
		"mage remove   - Remove the .DELTΔ directory from your home folder.\n" +
		"mage clean    - Clean build and db files from proj dir.\n"

	fmt.Println(helpMsg)
	return nil
}

// A Step-By-Step Setup Wizard For DELTΔ
func Wizard() error {
	// ATM ... we're just shoving a static-link in here
	// in game/res to the top-level /res dir so we can still
	// do stuff like `go run` and `go build` by choice.

	// This will eventually be under something like a
	// "other options" section in the wizard.

	// Get current working directory
	currDir, err := getCurrentWorkingDir()
	if err != nil {
		return err
	}
	// Create the static link
	resLink := filepath.Join(currDir, "game", "res")
	// Note: This requires running as an admin on Windows afaict.
	err = os.Symlink(filepath.Join(currDir, "res"), resLink)
	if err != nil {
		return err
	}
	fmt.Println("Static link created successfully.")
	return nil
}

// Grab The Server Side If It's Not Already Available. And Run It.
func Serve() error {
	// Get current working directory.
	currDir, err := getCurrentWorkingDir()
	if err != nil {
		return err
	}
	servDir := filepath.Join(currDir, "serv")

	if _, err := os.Stat(servDir); os.IsNotExist(err) {
		// Clone the serva repository.
		cmd := exec.Command("git", "clone", "https://github.com/delta-game/serva", "serv")
		cmd.Dir = currDir
		if err := cmd.Run(); err != nil {
			return err
		}
	}
	// Check for serva binary.
	servaBinary := filepath.Join(servDir, "serv")
	if _, err := os.Stat(servaBinary); os.IsNotExist(err) {
		cmd := exec.Command("go", "build")
		cmd.Dir = servDir
		if err := cmd.Run(); err != nil {
			return err
		}
	}
	// Run serva binary.
	if err := runCommandInDir("go run .", servDir); err != nil {
		return err
	}

	// THIS NO LONGER-WORKS FOR SOME REASON ...
	// CHECK THE WHOLE FUNC AND IF IT'S EVEN GETTING TO THIS POINT.
	fmt.Println("Serva is now running on port 8421")
	return nil
}

// Switch between main and g3n branches.
func Switch() error {
	// Check the current branch.
	currentBranch, err := getCurrentBranch()
	if err != nil {
		return err
	}

	var targetBranch string
	// Determine the target branch to switch to based on the current branch.
	switch currentBranch {
	case "main":
		targetBranch = "g3n"
	case "g3n":
		targetBranch = "main"
	default:
		return fmt.Errorf("Current branch is neither main nor g3n")
	}

	// // Uglier way, need to see if above actually works when I make a G3N branch.

	//     if currentBranch == "main" {
	//                targetBranch = "g3n"
	//        } else if currentBranch == "g3n" {
	//                targetBranch = "main"
	//       } else {
	//               return fmt.Errorf("Current branch is neither main nor g3n")
	//       }

	fmt.Printf("Switching from %s to %s branch...\n", currentBranch, targetBranch)

	// Checkout the target branch.
	err = sh.Run("git", "checkout", targetBranch)
	if err != nil {
		return fmt.Errorf("Failed to switch to %s branch. Please check your internet connection and also ... make sure %s hasn't been merged into %s branch!", targetBranch, targetBranch, currentBranch)
	}

	// Pull the latest changes from the target branch.
	err = sh.Run("git", "pull", "origin", targetBranch)
	if err != nil {
		return err
	}

	fmt.Printf("Successfully switched to %s branch!\n", targetBranch)

	return nil
}

// Update Your Current Repo With Git.
func Update() error {
	// Check if git is installed on your system.
	_, err := exec.LookPath("git")
	if err != nil {
		fmt.Println("Please install git to update the project.")
		return nil
	}
	// Check if current directory is a git repo.
	cmd := exec.Command("git", "rev-parse", "--is-inside-work-tree")
	out, err := cmd.Output()
	if err != nil {
		return err
	}
	if strings.TrimSpace(string(out)) != "true" {
		fmt.Println("Current directory is not a git repository.")
		return nil
	}
	// Run git pull command
	cmd = exec.Command("git", "pull")
	_, err = cmd.Output()
	if err != nil {
		return err
	}
	fmt.Println("Project updated successfully.")
	return nil
}

// Depends checks the operating system and, if on Linux, the specific distribution... then runs platform specific commands to grab dependencies.

func Depends() error {
	fmt.Println("Checking operating system and distribution...")

	switch os := runtime.GOOS; os {
    case "windows":
        // Check for Chocolatey package-manager
        _, err := exec.LookPath("choco")
        if err != nil {
            fmt.Println("Please install Chocolatey package manager to automatically resolve dependencies. https://chocolatey.org/")
            return nil
        }
        // Run command to install depends using Chocolatey
        cmd := exec.Command("powershell", "choco", "install", "-y", "glfw3", "golang", "git")
        _, err = cmd.Output()
        if err != nil {
            return err
        }
    case "darwin":
        // Check for Homebrew package-manager
        _, err := exec.LookPath("brew")
        if err != nil {
            fmt.Println("Please install Homebrew package manager to automatically resolve dependencies. https://brew.sh/")
            return nil
        }
        // Run command to install depends using Homebrew
        cmd := exec.Command("brew", "install", "glfw", "golang", "git")
        _, err = cmd.Output()
        if err != nil {
            return err
        }
	case "linux":
		fmt.Print("Running on Linux")
		// Check the specific distribution
		if dist, err := exec.Command("lsb_release", "-si").Output(); err == nil {
			distStr := strings.TrimSpace(string(dist))
			fmt.Printf("(%s)", distStr)
			// Update the package list for Debian and Ubuntu
			if strings.Contains(distStr, "Debian") || strings.Contains(distStr, "Ubuntu") {
				fmt.Printf("\n\nWe're Going To Install Some Dependencies For Ya.\n")
				if err := exec.Command("sudo", "apt", "install", "-y", "golang", "xorg-dev", "libgl1-mesa-dev", "libopenal1", "libopenal-dev", "libvorbis0a", "libvorbis-dev", "libvorbisfile3").Run(); err != nil {
					return err
				}
				fmt.Println("\nDependencies Installed Successfully!")
			} else if strings.Contains(distStr, "Fedora") {
				if err := exec.Command("sudo", "dnf", "install", "-y", "golang", "glfw", "xorg-x11-proto-devel", "mesa-libGL", "mesa-libGL-devel", "openal-soft", "openal-soft-devel", "libvorbis", "libvorbis-devel", "glfw-devel", "libXi-devel", "libXxf86vm-devel").Run(); err != nil {
					return err
				}
			} else if strings.Contains(distStr, "Arch") {
				if err := exec.Command("sudo", "pacman", "-S", "--noconfirm", "go", "base-devel", "xorg-server", "mesa", "openal", "libvorbis").Run(); err != nil {
					return err
				}
			} else {
				fmt.Println("\nSorry, automatic dependency resolution isn't ready yet for your distro. We only ``officially`` support Debian Bookworm, but working on Fedora, and Arch support. Probably moving to /etc/os-release.")
			}
		} else {
			return err
		}
		fmt.Println()
	default:
		fmt.Printf("Running on %s\n", os)
	}

	return nil
}

// Compiles the Go binary.
func Build() error {
	fmt.Println("Building DELTΔ Binary...")

	// Change directory to "game/".
	if err := os.Chdir("game/"); err != nil {
		return err
	}

	// Compile the Go binary using "go build" command.
	exec.Command("go", "mod", "tidy")
	cmd := exec.Command("go", "build", "-o", "../delta")
	err := cmd.Run()
	if err != nil {
		fmt.Println("\nCouldn't build the binary! Try running `mage depends` first.")
		return err
	}

	// Change directory back to the previous directory.
	if err := os.Chdir(".."); err != nil {
		return err
	}

	fmt.Println("Go binary built successfully!")
	return nil
}

// Executes the binary after building.
func Run() error {
	fmt.Println("Running DELTΔ...")

	// Execute the binary.
	err := sh.Run("./delta")
	if err != nil {
		fmt.Println("\nBinary not found! Please run `mage build` first!")
		return err
	}

	return nil
}

// Builds and executes the Go binary.
func Rerun() error {
	mg.SerialDeps(Build, Run)
	return nil
}

// Install creates an ~/.DELTΔ directory and copies the binary, database, and resources into it.
func Install() error {
	// Get the current user's home directory.
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return err
	}

	// Check if the .DELTΔ directory exists in the home directory.
	ΔDir := filepath.Join(homeDir, ".DELTΔ")
	if _, err := os.Stat(ΔDir); os.IsNotExist(err) {
		// If it doesn't, create it.
		if err := os.Mkdir(ΔDir, 0755); err != nil {
			return err
		}
	}

	// Copy the binary, database, and resources to the .DELTΔ directory.
	binPath := filepath.Join(".", "delta")
	binDest := filepath.Join(ΔDir, "game")

	dbPath := filepath.Join(".", "Δ.db")
	dbDest := filepath.Join(ΔDir, "Δ.db")

	resPath := filepath.Join(".", "res")
	resDest := filepath.Join(ΔDir, "res")

	// Ensure that the destination directories exist.
	if err := os.MkdirAll(filepath.Dir(binDest), 0755); err != nil {
		return err
	}
	if err := os.MkdirAll(filepath.Dir(dbDest), 0755); err != nil {
		return err
	}
	if err := os.MkdirAll(resDest, 0755); err != nil {
		return err
	}

	// Copy the files.
	if err := sh.Copy(binDest, binPath); err != nil {
		return err
	}
	if err := sh.Copy(dbDest, dbPath); err != nil {
		return err
	}
	if err := copyDir(resPath, resDest); err != nil {
		return err
	}

	fmt.Println("Binary installed successfully!")
	return nil
}

// Remove The ~/.DELTΔ Directory.
func Remove() error {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return err
	}
	// Remove the /opt/DELTΔ folder and all its contents.
	ΔDir := filepath.Join(homeDir, ".DELTΔ")
	if _, err := os.Stat(ΔDir); os.IsNotExist(err) {
		fmt.Println(".DELTΔ directory does not exist, nothing to remove.")
		return nil
	}

	err = os.RemoveAll(ΔDir)
	if err != nil {
		return err
	}

	fmt.Println(".DELTΔ directory removed successfully!")
	return nil
}

// Clean Up Project Directory.
func Clean() error {
	// Get current working directory.
	currDir, err := os.Getwd()
	if err != nil {
		return err
	}

	// Remove binary if it exists.
	binPath := filepath.Join(currDir, "delta")
	if _, err := os.Stat(binPath); !os.IsNotExist(err) {
		if err := os.Remove(binPath); err != nil {
			return err
		}
	}

	// Remove Database file if it exists.
	dbPath := filepath.Join(currDir, "Δ.db")
	if _, err := os.Stat(dbPath); !os.IsNotExist(err) {
		if err := os.Remove(dbPath); err != nil {
			return err
		}

	}
	// Remove serv directory if it exists.
	servDir := filepath.Join(currDir, "serv")
	if _, err := os.Stat(servDir); !os.IsNotExist(err) {
		if err := os.RemoveAll(servDir); err != nil {
			return err
		}
	}

	// Remove res static link if it exists.
	resLink := filepath.Join(currDir, "game", "res")
	if _, err := os.Stat(resLink); !os.IsNotExist(err) {
		if err := os.Remove(resLink); err != nil {
			return err
		}
	}

	fmt.Println("Project directory cleaned successfully!")
	return nil
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

// We're going to drop a bunch of misc utility functions and vars down here.
// Basically things / patterns I notice I do a lot in the heart of the Magefile
// I'm going to move down here. As-well as any dark-magick ugly hacks there may be.

func runCommandInDir(command string, dir string) error {
	cmd := exec.Command("sh", "-c", command)
	cmd.Dir = dir
	if err := cmd.Run(); err != nil {
		return err
	}
	return nil
}

func getCurrentBranch() (string, error) {
	cmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
	out, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to get current branch: %w", err)
	}
	return strings.TrimSpace(string(out)), nil
}

func getCurrentWorkingDir() (string, error) {
	currDir, err := os.Getwd()
	if err != nil {
		return "", err
	}
	return currDir, nil
}

func changeWorkingDir(dir string) error {
	if err := os.Chdir(dir); err != nil {
		return err
	}
	return nil
}

func copyDir(src, dst string) error {
	err := os.MkdirAll(dst, 0755)
	if err != nil {
		return err
	}

	return filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		relPath, err := filepath.Rel(src, path)
		if err != nil {
			return err
		}

		dstPath := filepath.Join(dst, relPath)

		if info.IsDir() {
			return os.MkdirAll(dstPath, info.Mode().Perm())
		}

		srcFile, err := os.Open(path)
		if err != nil {
			return err
		}
		defer srcFile.Close()

		dstFile, err := os.Create(dstPath)
		if err != nil {
			return err
		}
		defer dstFile.Close()

		if _, err := io.Copy(dstFile, srcFile); err != nil {
			return err
		}

		return nil
	})
}
